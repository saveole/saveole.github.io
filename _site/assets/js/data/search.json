[
  
  {
    "title": "Saveole's Tech Review, Issue 1",
    "url": "/posts/saveole-tech-review-1/",
    "categories": "Randomly",
    "tags": "Java, ZGC, Virtual Thread, eBPF",
    "date": "2025-03-21 21:50:30 +0800",
    





    
    "snippet": "Post      Java                  JDK 24 发布了！                  JDK 24 最近(2025-03-18)发布了, 讲下几个让我感兴趣的地方吧。                      Compact Object Headers                              压缩对象头：将 64 位机器的 HotSpo...",
    "content": "Post      Java                  JDK 24 发布了！                  JDK 24 最近(2025-03-18)发布了, 讲下几个让我感兴趣的地方吧。                      Compact Object Headers                              压缩对象头：将 64 位机器的 HotSpot JVM 对象头从 96 - 128 位压缩为 64 位，且保证由此造成的吞吐/延迟损失不超过 5%，相关的项目是 Liliput。Java 一直以较大的内存开销闻名，很大一块原因就是 Java 对象的冗余设计，在云原生时代这的确是一个劣势。好在社区在这块终于有所动作，最近会花时间看看压缩对象头在内存这块有多大提升。                                      Stream Gatherers                              这个 JEP 是对 Stream API 的增强，用户能够自定义构建流的中间(如 jdk 提供的 filter/map/flatMap/distinct/limit 等返回 Stream&lt;T&gt; 的方法)操作，简单用法：source.gather(...).gather(...).gather(...).collect(...)。                                      Ahead-of-Time Class Loading &amp; Linking                              加速 JVM 应用启动时间的技术，通过监控和存储系统在运行时的 class 等信息，在下次启动时直接链接/加载上次存储的文件到内存直接运行，大大减少应用的启动时间。                                      Prepare to Restrict the Use of JNI                              开始限制 JNI 的使用，引导开发者使用 Foreign Function &amp; Memory API。                                      Class-File API                              直接操作字节码文件的 API，因为 Java 六个月的发版节奏导致字节码文件格式变化加快，怕第三方字节码操作库如 ASM 等跟不上节奏，官方自己下场干活了，这对于 APM 类软件研发可能是更好的选择。                                      Module Import Declarations (Second Preview)                              类似将 import java.util.*  的引用变更为 import module java.base，如果引用某一个模块的类比较多的话，还是能大大简化 import 语句的。                                      ZGC: Remove the Non-Generational Mode                              上个版本 ZGC 默认使用分代模式，这个版本中是移除 ZGC 的非分代模型。                                      Permanently Disable the Security Manager                              JDK 17 中开始准备移除 Security Manager，现在正式永久移除。                                      Synchronize Virtual Threads without Pinning                              之前版本的 Virtual Thread + synchronized 在执行方法出现阻塞(例如 IO 场景)(pinning)的情况下，VT 不能 unmount 其依赖的底层 OS 线程，可能导致线程饥饿甚至死锁等问题(可以通过 jdk.VirtualThreadPinned JFR 事件监控)，Netflix 团队之前也遇到过，JEP491 解决了这个问题。下面是一个由此导致的死锁代码案例：                                                    ```javaimport java.time.Duration;import java.util.List;import java.util.concurrent.locks.ReentrantLock;import java.util.stream.IntStream;import java.util.stream.Stream;/** * Demonstrate potential for deadlock on a {@link ReentrantLock} when there is both a synchronized and * non-synchronized path to that lock, which can allow a virtual thread to hold the lock, but * other pinned waiters to consume all the available workers. */public class VirtualThreadReentrantLockDeadlock {    public static void main(String[] args) {        final boolean shouldPin = args.length == 0 ||Boolean.parseBoolean(args[0]);        final ReentrantLock lock = new ReentrantLock(true); // With faireness to ensure that the unpinned thread is next in line        lock.lock();            Runnable takeLock = () -&gt; {            try {                System.out.println(Thread.currentThread() + \" waiting for lock\");                lock.lock();                System.out.println(Thread.currentThread() + \" took lock\");            } finally {                lock.unlock();                System.out.println(Thread.currentThread() + \" released lock\");            }        };        Thread unpinnedThread = Thread.ofVirtual().name(\"unpinned\").start(takeLock);        List&lt;Thread&gt; pinnedThreads = IntStream.range(0, Runtime.getRuntime().availableProcessors())    .mapToObj(i -&gt; Thread.ofVirtual().name(\"pinning-\" + i).start(() -&gt; {                if (shouldPin) {                    synchronized (new Object()) {                        takeLock.run();                    }                } else {                    takeLock.run();                }            })).toList();            lock.unlock();            Stream.concat(Stream.of(unpinnedThread), pinnedThreads.stream()).forEach(thread -&gt; {            try {                if (!thread.join(Duration.ofSeconds(3))) {                    throw new RuntimeException(\"Deadlock detected\");                                    }            } catch (InterruptedException e) {                throw new RuntimeException(e);            }        });    }}```    ```(base) saveole@saveoledeMacBook-Pro src % java VirtualThreadReentrantLockDeadlock.javaVirtualThread[#25,unpinned]/runnable@ForkJoinPool-1-worker-1 waiting for lockVirtualThread[#28,pinning-0]/runnable@ForkJoinPool-1-worker-1 waiting for lockVirtualThread[#30,pinning-2]/runnable@ForkJoinPool-1-worker-3 waiting for lockVirtualThread[#29,pinning-1]/runnable@ForkJoinPool-1-worker-2 waiting for lockVirtualThread[#33,pinning-5]/runnable@ForkJoinPool-1-worker-6 waiting for lockVirtualThread[#31,pinning-3]/runnable@ForkJoinPool-1-worker-4 waiting for lockVirtualThread[#35,pinning-7]/runnable@ForkJoinPool-1-worker-9 waiting for lockVirtualThread[#32,pinning-4]/runnable@ForkJoinPool-1-worker-5 waiting for lockVirtualThread[#34,pinning-6]/runnable@ForkJoinPool-1-worker-7 waiting for lockVirtualThread[#36,pinning-8]/runnable@ForkJoinPool-1-worker-8 waiting for lockVirtualThread[#38,pinning-9]/runnable@ForkJoinPool-1-worker-10 waiting for lockException in thread \"main\" java.lang.RuntimeException: Deadlock detectedat VirtualThreadReentrantLockDeadlock.lambda$main$3(VirtualThreadReentrantLockDeadlock.java:49)at java.base/java.util.stream.Streams$StreamBuilderImpl.forEachRemaining(Streams.java:411)at java.base/java.util.stream.Streams$ConcatSpliterator.forEachRemaining(Streams.java:734)at java.base/java.util.stream.ReferencePipeline$Head.forEach(ReferencePipeline.java:762)at VirtualThreadReentrantLockDeadlock.main(VirtualThreadReentrantLockDeadlock.java:46)```                            Reproducing a Java 21 virtual threads deadlock scenario with TLA+                  ​对 Java 21 虚拟线程 + synchronized 造成死锁的解释文章，值得一看。                          Spring Framework 7.0 - preview 版本          Programmatic Bean Registration                  编程化控制 Spring Bean 的注册逻辑，可以和 Spring AOT 以及 GraalVM native images 兼容使用。                    Null-safety                  使用 Jspecify 进行 Null 值注解方式检查。                    API versioning support in web applications                  通过在 @RequestMapping 中指定 API 版本路由到不同的 controller 方法中。                    Optional support with null-safe and Elvis operators in SpEL expressions                  终于！！！ SpEL + Optional : Optional&lt;User&gt; -&gt; user?.nameSpEL + 三目表达式 : (name != null ? name : \"Unknown\") -&gt; \"name ?: 'Unknown'\"                    GitHub  eclipse-jifa/jifa - 在线 GC 日志/Heap Dump/JFR 文件可视化分析工具。  java24-demo - JDK24 特性相关的代码示例和解释。  hello-ebpf - 用 Java 代码写 eBPF 程序。Video  Project Lilliput - Beyond Compact Headers  Build a lightning fast Firewall with Java &amp; eBPF - Johannes Bechberger - CPH DevFest 2024Book  NaN"
  },
  
  {
    "title": "Unit Test with Mockito",
    "url": "/posts/unit-test-with-Mockito/",
    "categories": "Test",
    "tags": "Java, Mockito, Unit Test, Spring",
    "date": "2025-03-01 17:10:31 +0800",
    





    
    "snippet": "Unit Test with MockitoTags: ItTest, Mock, MockStatic, Spring Event, UT, 未发布备注: should be a blog in my Github blog project in some time      when … thenReturn … 当执行某些方法时返回 mock 数据。      // userServi...",
    "content": "Unit Test with MockitoTags: ItTest, Mock, MockStatic, Spring Event, UT, 未发布备注: should be a blog in my Github blog project in some time      when … thenReturn … 当执行某些方法时返回 mock 数据。      // userService should be annotated with @Mock  when(userService).thenReturn(some_mock_value);            when … thenReturn … 可以链式 thenReturn 多个 mock 值用于指定方法多次调用时返回不同的值。      @Test  @DisplayName(\"每日分配上限测试-轮流分配+中间员工无分配权限\")  void test_daily_limit_with_middle_limit_0_should_ok() {      when(mongoTemplate.find(any(), eq(ClueAutomaticAllot.class))).thenReturn(mockAllots);      when(mongoTemplate.updateFirst(any(), any(), eq(defaultColl))).thenReturn(mockResult());      when(clueAutomaticAllotRepo.saveAll(mockAllots)).thenReturn(null);      when(userService.findAllByUserIdsIn(anyList()))              .thenReturn(mockUserAllOnDuty(allotUserIds))              .thenReturn(mockUserAllOnDuty(List.of(\"627a29d4b3e8940001ae07b0\")))              .thenReturn(mockUserAllOnDuty(List.of(\"627a29d4b3e8940001ae07b0\")));      when(mongoTemplate.aggregate(any(Aggregation.class), eq(defaultColl), eq(UserAllotData.class)))              .thenReturn(mockAggResultEmpty())              .thenReturn(mockAggResultWithLimit_1())              .thenReturn(mockAggResultWithLimit_2());          // 第一次分配给用户1      clueAutomaticAllotService.autoAllot(mockInsertTask(List.of(matchPoolAndChannel_1())));      assertEquals(\"61c877b13222fa00011c91bb\", mockAllots.get(1).getLastAllotUser());      // 第二次分配给用户3      clueAutomaticAllotService.autoAllot(mockInsertTask(List.of(matchPoolAndChannel_1())));      assertEquals(\"627a29d4b3e8940001ae07b0\", mockAllots.get(1).getLastAllotUser());      // 第三次分配给用户3      clueAutomaticAllotService.autoAllot(mockInsertTask(List.of(matchPoolAndChannel_1())));      assertEquals(\"627a29d4b3e8940001ae07b0\", mockAllots.get(1).getLastAllotUser());          // 相应的 event 事件代码逻辑应该执行了三次      verify(opLogService, times(3)).publishOplog(any(OpLog.class));      verify(eventPublisher, times(3)).publishEvent(any(ReclaimTaskEvent.class));  }            thenAnswer() 根据方法参数动态灵活的返回数据。      @ExtendWith(MockitoExtension.class)  class PersonServiceTest {          @Mock      PersonRepository repository;          @InjectMocks      PersonService service;          List&lt;Person&gt; people = List.of(              new Person(\"1\", \"jack\", 15),              new Person(\"2\", \"jacsk\", 16),              new Person(\"3\", \"jackie\", 17)      );          @Test      void saveAllPeople() {          when(repository.save(any(Person.class))) // mock save 操作                  .thenAnswer(invocation -&gt; invocation.getArgument(0)); // 返回传入的参数          var ids = service.savePeople(people);          assertThat(ids).hasSize(3); // 验证保存了 3 个对象      }  }            doNothing().when(mock).method(any(Argument.class))  适用 void 方法      doNothing().when(eventPublisher).publishEvent(any(ReclaimTaskEvent.class));        mockStatic  静态方法 mock          前提：在 resources 文件夹下创建 mockito-extensions 文件夹，创建   org.mockito.plugins.MockMaker 文件，内容为：mock-maker-inline              single static method          try (MockStatic&lt;StaticClass&gt; staticClass = Mockito.mockStatic(StaticClass.class)) {      staticClass.when(StaticClsss::staticMethod).thenReturn(some_mock_value);  }                    nested static methods                  nested try blocks with Mockito mockStatic statement！                  try (MockedStatic&lt;ServletUtil&gt; servletUtilMockedStatic = Mockito.mockStatic(ServletUtil.class)) {      try (MockedStatic&lt;ContextUtil&gt; contextUtilMockedStatic = Mockito.mockStatic(ContextUtil.class)) {          contextUtilMockedStatic.when(ContextUtil::getServletRequest).thenReturn(null);          contextUtilMockedStatic.when(ContextUtil::currentCusColl).thenReturn(cusColl);          servletUtilMockedStatic.when(() -&gt; ServletUtil.getClientIP(null)).thenReturn(\"0.0.0.0\");          ModifyResult result = customerService.pickUp(List.of(notDistributedOne));          assertEquals(1, result.getSuccessCount());          assertEquals(0, result.getFailedCount());          // 更新后数据校验          LinkedHashMap updated = findOne(notDistributedOne);          assertEquals(\"已分配\", updated.get(\"分配状态\"));          assertEquals(user.getId(), updated.get(\"followUser\"));          assertEquals(user.getName(), updated.get(\"跟进人\"));          assertEquals(user.getName(), updated.get(\"最近操作人\"));          assertEquals(1, updated.get(\"领取次数\"));      }  }                          验证方法执行次数 verify + times      // 校验发布事件次数  verify(eventPublisher, times(1)).publishEvent(any(ReclaimTaskEvent.class));  verify(eventPublisher, times(1)).publishEvent(any(OpLog.class));            验证方法执行顺序 inOrder      // verify the methods are called once, in the right order  InOrder inOrder = inOrder(repository, translationService);  inOrder.verify(repository).findById(anyInt());  inOrder.verify(translationService).translate(anyString(), eq(\"en\"), eq(\"en\"));            spy() 用于部分 mock          You can intercept method calls to the dependencies for later verification.      You can mock some methods in the dependencies rather than all of them. This is called a partial mock.          @Test  void spyOnRepository() {      // Spy on the in-memory repository  \t\tPersonRepository personRepo = spy(new InMemoryPersonRepository());   \t\tPersonService personService = new PersonService(personRepo);  \t\tpersonService.savePeople(people.toArray(Person[]::new)); assertThat(personRepo.findAll()).isEqualTo(people);      // Verify the method calls on the spy      verify(personRepo, times(people.size())).save(any(Person.class));  }        方法入参校验 ArgumentMatcher          基本类型系列：anyByte, anyShort, anyInt, anyLong, anyFloat, anyDouble, anyChar, and anyBoolean.      集合类型系列：anyCollection, anyList, anySet, and anyMap      字符串系列：anyString, startsWith, endsWith, and the two overloads of matches, one that takes a regular expression as a string and the other a Pattern.      null 检查：isNull and isNotNull (and its companion, notNull, which is just an alias), and nullable(Class), which matches either null or a given type.      等值判断：eq()        自定义方法入参校验器          实现 ArgumentMatcher&lt;T&gt;      argThat() + lambda Predicate        ⚠️ 如果是基本类型参数需要对应使用 byteThat, shortThat, charThat, intThat, longThat, floatThat, doubleThat, and booleanThat. 此举可避免因为装拆箱问题引起的 NPE 问题。      when(userRepo.findById(argThat(id -&gt; id.startsWith(\"user\")))).thenReturn(Optional.of(user));        Spring Boot Application Event Test  @DataMongoTest with testcontainers      BDDMockito given/when/then 写法：      @Test  public void findMaxId_BDD() {      given(repository.findAll()).willReturn(people);      assertThat(service.getHighestId()).isEqualTo(14);      then(repository).should().findAll();  }        Mock send spring event and consume spring event                  针对 ApplicationEvent 事件可以断言单个方法内发送了几次 event.          // 校验发布事件次数  verify(eventPublisher, times(1)).publishEvent(any(ReclaimTaskEvent.class));  verify(eventPublisher, times(1)).publishEvent(any(OpLog.class));                          How to assert a rest api with MockMvc      MvcResult result = mockMvc.perform(post(\"/api/users\").header(\"Authorization\", base64ForTestUser).contentType(MediaType.APPLICATION_JSON)              .content(\"{\\\"userName\\\":\\\"testUserDetails\\\",\\\"firstName\\\":\\\"xxx\\\",\\\"lastName\\\":\\\"xxx\\\",\\\"password\\\":\\\"xxx\\\"}\"))              .andDo(MockMvcResultHandlers.print())              .andExpect(status().isBadRequest())  \t\t\t\t\t\t.andExpect(jsonPath(\"data.total\").value(5))  \t\t\t\t\t\t// 对于 json 数组的中元素字段进行断言  \t\t\t\t\t\t.andExpect(jsonPath(\"data.content.[0].createUser\").value(\"62c7ec65baaca09ad14dbd9f\"))  \t\t\t\t\t\t// todo 也会有中文乱码问题  \t\t\t\t\t\t.andExpect(content().string(Matchers.containsString(\"expected string\")))              .andReturn();      // 指定编码防止中文乱码  String content = result.getResponse().getContentAsString(StandardCharsets.UTF_8);  // do what you want, usually do some assertions      Mock, Stub, Spy"
  },
  
  {
    "title": "Saveole's Tech Review, Issue 0",
    "url": "/posts/saveole-tech-review-0/",
    "categories": "Randomly",
    "tags": "Java, SSE, ZGC, Go, Raft",
    "date": "2024-09-21 16:50:30 +0800",
    





    
    "snippet": "Post      Java                  JDK 23 发布了！                  ​        前不久，go 发布了 1.23 版本，Java 最近也如期发布了 JDK 23(none tls)，主要更新大部分还是 preview 阶段的提案，个人印象深刻点的 一(JEP474)是 ZGC 默认使用分代模式(Generational Mode), ...",
    "content": "Post      Java                  JDK 23 发布了！                  ​        前不久，go 发布了 1.23 版本，Java 最近也如期发布了 JDK 23(none tls)，主要更新大部分还是 preview 阶段的提案，个人印象深刻点的 一(JEP474)是 ZGC 默认使用分代模式(Generational Mode), 二(JEP471)是 sun.misc.Unsafe 的大部分 memory-access 相关的方法被标记 @Deprecated 了，以后会移除，类库的开发者需要额外注意下，可以用 JEP 193 和 JEP 454 中提及的 API 替代。ps: 从 471 看，Java 的更新还是很克制的，充分考虑到老用户的兼容问题，但另一方面也可以看到 Java 的大体量对于新事物的推广还是很慢的，现在 Java 使用最多的版本还是 Java 8，我在面试候选人的时候一说起 Java 的新特性是 Lambda/Stream 流的时候就皱起了眉头 😂          ​        也可看看 foojay 上这篇对于 JDK 23 的解读文章。                            Spring Boot CDS support and Project Leyden anticipation                  ​        介绍了如何使用 Spring Boot 3.3 + CDS + Leydon + Spring Native 构建应用程序以显著减少 Spring Boot 应用的启动时间和运行时内存消耗，非常推荐看一看试一试。                            Bending pause times to your will with Generational ZGC                  ​        Netflix 使用 JDK21 + 分代 ZGC 的实践，非常好，俺也想在生产环境试试 🐶                          Go                  How to implement Server-Sent Events in Go                  ​        SSE(Server-Sent Events) 是服务器向客户端不断发送 event 的单向通信协议(不同于 WebSocket 的双向通信 )，底层也是基于 HTTP，可以用于需要服务端实时生成内容的场景，如 ChatGPT 的流式相应等。          ​        这篇文章使用 go 的 net/http 实现了一个简单的 SSE 案例，可以看到 go 的基础类库还是很强大的，比 Java 要简洁很多。          前不久使用 gin 框架也实现了 SSE：          func ScriptRecognize(c *gin.Context) {\tid := c.Param(\"id\")\tvar record models.ScriptUploadRecord\terr := models.FindOne(common.TB_SCRIPT, bson.M{\"_id\": bson.ObjectIdHex(id)}, nil, &amp;record)\tif err != nil {\t\tc.JSON(http.StatusOK, helpers.Fail(err))\t\treturn\t}\tif len(record.Texts) &gt; 0 {\t\ttxt := strings.Join(record.Texts, \"\")\t\tc.Stream(func(w io.Writer) bool {\t\t\tc.String(200, \"data: %s\\n\\n\", txt)\t\t\treturn false\t\t})\t\treturn\t}\tchanStream := make(chan string, 100)\tgo recognizer.RecognizeFromUrl(record.FileUrl, chanStream)\tcontent := make([]string, 0)\tc.Header(\"Content-Type\", \"text/event-stream\")\tc.Header(\"X-Accel-Buffering\", \"no\")\tc.Stream(func(w io.Writer) bool {\t\tif msg, ok := &lt;-chanStream; ok {\t\t\tfmt.Printf(\"转文本：%s\", msg)\t\t\tc.String(200, \"data: %s\\n\\n\", msg)\t\t\tcontent = append(content, msg)\t\t\treturn true\t\t}\t\tgo updateScript(id, \"texts\", content)\t\treturn false\t})}                    ​        主要注意的就是：1. header 的控制参数 2. event 发送的格式                            Don’t defer Close() on writable files                  ​        不要因为使用了 defer io.Closer.Close() 而忽略了后续操作系统因为 close syscall 不成功产生的 error ,建议用 return f.Close() –&gt; os 还是不一定马上刷盘，或者 return f.Sync() –&gt; 马上刷盘，严重影响性能。                            Implementing Raft: Part 2 - Commands and Log Replication                  ​        一个实现简单 raft 协议的国外教程的 Log Replication 部分，翔实的 test case 以及 log 可视化(html 表格对比形式)做的很好，要是做成动态可视化就更好了。                    GitHub  petclinic-efficient-container - 经典 Spring Boot 演示项目 spring-petclinic 的优化版  eraft - 一步步实现 raft 协议并打造一个分布式 KV 存储  starflare - 给自己 star 的项目分类/打标签  omakub - 配置全新安装的 Ubuntu 的工具Video  Implementing Domain Driven Design with Spring by Maciej Walkowiak @ Spring I/O 2024Book      Build Your Own Database From Scratch in Go          看了一点，感觉很不错，最近在实现 raft 的时候发现 go 基础很不好，先补基础，后面再来学习。      "
  },
  
  {
    "title": "用 Slidev 写 PPT 并使用 Github Pages 部署到自己的博客上",
    "url": "/posts/use-slidev-make-ppt-and-deploy-to-giithub-pages/",
    "categories": "博客",
    "tags": "Blog, PPT",
    "date": "2024-07-24 17:55:00 +0800",
    





    
    "snippet": "      Prerequisites          基于 Github Pages 构建的静态个人博客网站            Steps                  使用 Slidev 创建自己的 ppt 项目并上传到 Github 上的单独 Repository                    配置开启仓库的 Github Pages                 ...",
    "content": "      Prerequisites          基于 Github Pages 构建的静态个人博客网站            Steps                  使用 Slidev 创建自己的 ppt 项目并上传到 Github 上的单独 Repository                    配置开启仓库的 Github Pages                      配置 Github Action                  我的 .github/workflows/deploy.yml 如下：                  # Simple workflow for deploying static content to GitHub Pages  name: Deploy static content to Pages          on:    # Runs on pushes targeting the default branch    push:      branches: [\"main\"]            # Allows you to run this workflow manually from the Actions tab    workflow_dispatch:          # Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages  permissions:    contents: read    pages: write    id-token: write          # Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued.  # However, do NOT cancel in-progress runs as we want to allow these production deployments to complete.  concurrency:    group: \"pages\"    cancel-in-progress: false          jobs:    # Single deploy job since we're just deploying    deploy:      environment:        name: github-pages        url: $      runs-on: ubuntu-latest      steps:        - name: Checkout          uses: actions/checkout@v4        - name: Setup node          uses: actions/setup-node@v4          with:            node-version: \"lts/*\"        - name: Install dependencies          run: npm install        - name: Install slidev          run: npm i -g @slidev/cli        - name: Build          run: slidev build --base /java_app_build_docker_image/        - name: Setup Pages          uses: actions/configure-pages@v5        - name: Upload artifact          uses: actions/upload-pages-artifact@v3          with:            # Upload entire repository            path: dist        - name: Deploy to GitHub Pages          id: deployment          uses: actions/deploy-pages@v4                          Finish          写好 ppt 后，push 到仓库自动构建部署到自己的个人博客中，效果：Java 应用如何构建 Docker 镜像            Notes:          slidev build --base /java_app_build_docker_image/ 需要指定特定子路由的时候，最好将子路由名称和仓库名称保持一致      我构建部署好的 ppt 地址在 Edge 浏览器下没有默认重定向到 /1 即 ppt 首页，但 FireFox 就可以，很奇怪，待我看看.      使用的 Slidev 主题：academic      参考的 PPT： exploring-social-engineering-slides      "
  },
  
  {
    "title": "Java 应用如何构建 Docker 镜像",
    "url": "/posts/java-app-docker-image/",
    "categories": "博客",
    "tags": "Java, Docker, APM, PPT",
    "date": "2024-07-22 18:10:00 +0800",
    





    
    "snippet": "  slide",
    "content": "  slide"
  },
  
  {
    "title": "博客方案：Jekyll + Chirpy",
    "url": "/posts/jekyll-chirpy/",
    "categories": "博客",
    "tags": "Jekyll",
    "date": "2024-05-31 13:38:00 +0800",
    





    
    "snippet": "  安装 Jekyll (Ubuntu 24.04)          先装 Ruby 和相关依赖项: sudo apt-get install ruby-full build-essential zlib1g-dev              设置当前用户有 gem 的执行权限          echo '# Install Ruby Gems to ~/gems' &gt;&gt; ~...",
    "content": "  安装 Jekyll (Ubuntu 24.04)          先装 Ruby 和相关依赖项: sudo apt-get install ruby-full build-essential zlib1g-dev              设置当前用户有 gem 的执行权限          echo '# Install Ruby Gems to ~/gems' &gt;&gt; ~/.bashrc  echo 'export GEM_HOME=\"$HOME/gems\"' &gt;&gt; ~/.bashrc  echo 'export PATH=\"$HOME/gems/bin:$PATH\"' &gt;&gt; ~/.bashrc  source ~/.bashrc                    安装 Jekyll: gem install jekyll bundler        使用 Chirpy 主题          Clone 或下载 https://github.com/cotes2020/chirpy-starter 仓库      安装依赖： bundle      启动项目： bundle exec jekyll s      访问：http://localhost:4000        基本配置及写 post          https://chirpy.cotes.page/posts/getting-started/      https://chirpy.cotes.page/posts/write-a-new-post/        初次感受          清新简洁，大方美观，响应迅速      定制项挺多，支持视频/音频等媒体格式      从自己平时写的 Markdown 文件转换过来要改造的内容也挺多的， 可以考虑写个程序做这个事情      其他更细致的体验待自己深入使用再评价            Changelog          准备使用这个作为自己的博客框架，先把博客写起来再谈其他              头像/联系方式等设置        favicon 替换        接入 giscus 评论系统 - martin‘s blog        接入 Google Analytics        国内网络环境加速 - 是否有必要？ 还是先输出内容为主，不做过早优化。              和 Gmeek 的简单对比          之前的博客框架主要根据 GitHub Issue as a Blog 和 Gmeek 快速上手 构建的。      Gmeek 是基于 GitHub Issues 的，最大的特点就是简洁, 然后是都基于 GitHub 平台，不用在本地安装各种环境，遇到的最大问题是之前 Gmeek 提供的 Github Action 脚本不兼容，导致后续的构建失败。      Chirpy 对于 Gmeek 的话，我个人感觉页面布局要好一点，可配置的地方也要丰富一点。      "
  },
  
  {
    "title": "GraalVM Native + Base64 编解码命令行小工具开发",
    "url": "/posts/graalvm-native-java-base64-command-line-tool/",
    "categories": "技术, Java",
    "tags": "GraalVM, Java, JShell",
    "date": "2024-04-29 13:38:00 +0800",
    





    
    "snippet": "  初衷：          浏览  V 站 帖子有很多 Base64 加密的信息，希望能够快速解密。        实现：                  v1：直接使用 JShell 命令行运行 Java 代码解密          ant@ant:~$ jshell   |  Welcome to JShell -- Version 17.0.9  |  For an introdu...",
    "content": "  初衷：          浏览  V 站 帖子有很多 Base64 加密的信息，希望能够快速解密。        实现：                  v1：直接使用 JShell 命令行运行 Java 代码解密          ant@ant:~$ jshell   |  Welcome to JShell -- Version 17.0.9  |  For an introduction type: /help intro          jshell&gt; var enc = \"c2F2ZW9sZQ==\"  enc ==&gt; \"c2F2ZW9sZQ==\"          jshell&gt; var decodedBytes = Base64.getDecoder().decode(enc.getBytes())  decodedBytes ==&gt; byte[8] { 115, 97, 118, 101, 95, 111, 108, 101 }          jshell&gt; new String(decodedBytes)  $3 ==&gt; \"saveole\"                            v2：GraalVM Native 的方式将 Java 程序编译打包成可执行文件小工具                              原 Java 程序：              import java.util.Base64;              public class Base64Tool {      static String helpMsg = \"\"\"  \t\t-e Encode input string  \t\t-d Decode input string               \"\"\";;                      public static void main(String[] args) {          if (args == null || args.length == 0) {              System.err.println(helpMsg);              System.exit(1);          }          var arg = args[0];          switch(arg) {            case \"-help\":                System.out.println(helpMsg);                break;            case \"-e\":                var toEncode = getAndCheckArg(args);                System.out.println(new String(Base64.getEncoder().encode(toEncode.getBytes())));                break;            case \"-d\":                var toDecode = getAndCheckArg(args);                System.out.println(new String(Base64.getDecoder().decode(toDecode.getBytes())));                break;            default:                System.err.println(\"Unknown command, use -help to see how to use this tool.\");                break;          }          System.exit(1);      }                  static String getAndCheckArg(String[] args) {          if (args == null || args.length &lt; 2) {              System.err.println(\"Please input valid string\");              System.exit(0);          }          return args[1];      }  }                                            使用 native-image 编译构建可执行程序              ant@ant:~/native$ javac Base64Tool.java   ant@ant:~/native$ native-image Base64Tool  ========================================================================================================================  GraalVM Native Image: Generating 'base64tool' (executable)...  ========================================================================================================================  [1/8] Initializing...                                                                                    (1.7s @ 0.14GB)   Java version: 17.0.9+9, vendor version: GraalVM CE 17.0.9+9.1   Graal compiler: optimization level: 2, target machine: x86-64-v3   C compiler: gcc (linux, x86_64, 11.4.0)   Garbage collector: Serial GC (max heap size: 80% of RAM)  [2/8] Performing analysis...  [****]                                                                     (4.4s @ 0.27GB)     2,912 (71.67%) of  4,063 types reachable     3,536 (50.94%) of  6,942 fields reachable    13,209 (43.86%) of 30,116 methods reachable       907 types,     0 fields, and   348 methods registered for reflection        58 types,    58 fields, and    52 methods registered for JNI access         4 native libraries: dl, pthread, rt, z  [3/8] Building universe...                                                                               (0.9s @ 0.30GB)  [4/8] Parsing methods...      [*]                                                                        (0.6s @ 0.32GB)  [5/8] Inlining methods...     [***]                                                                      (0.5s @ 0.22GB)  [6/8] Compiling methods...    [**]                                                                       (4.5s @ 0.35GB)  [7/8] Layouting methods...    [*]                                                                        (0.7s @ 0.37GB)  [8/8] Creating image...       [*]                                                                        (1.1s @ 0.38GB)     4.42MB (36.75%) for code area:     7,506 compilation units     7.04MB (58.46%) for image heap:   89,275 objects and 5 resources   590.55kB ( 4.79%) for other data    12.03MB in total  ------------------------------------------------------------------------------------------------------------------------  Top 10 origins of code area:                                Top 10 object types in image heap:     3.37MB java.base                                         1009.70kB byte[] for code metadata   795.13kB svm.jar (Native Image)                             889.53kB java.lang.String   112.32kB java.logging                                       836.32kB byte[] for general heap data    62.07kB org.graalvm.nativeimage.base                       671.94kB java.lang.Class    24.15kB jdk.internal.vm.ci                                 665.65kB byte[] for java.lang.String    23.14kB org.graalvm.sdk                                    347.48kB java.util.HashMap$Node     6.11kB jdk.internal.vm.compiler                           250.25kB com.oracle.svm.core.hub.DynamicHubCompanion     1.68kB Base64Tool                                         169.02kB java.lang.String[]     1.35kB jdk.proxy1                                         165.57kB java.lang.Object[]     1.27kB jdk.proxy3                                         148.84kB byte[] for embedded resources     1.56kB for 2 more packages                                  1.20MB for 829 more object types  ------------------------------------------------------------------------------------------------------------------------  Recommendations:   HEAP: Set max heap for improved and more predictable memory usage.   CPU:  Enable more CPU features with '-march=native' for improved performance.  ------------------------------------------------------------------------------------------------------------------------                          0.7s (4.3% of total time) in 164 GCs | Peak RSS: 0.84GB | CPU load: 8.21  ------------------------------------------------------------------------------------------------------------------------  Produced artifacts:   /home/ant/native/base64tool (executable)  ========================================================================================================================  Finished generating 'base64tool' in 14.8s.                                            使用              ant@ant:~/native$ ./base64tool -help  -e Encode input string  -d Decode input string              ant@ant:~/native$ ./base64tool -e saveole  c2F2ZW9sZQ==  ant@ant:~/native$ ./base64tool -d c2F2ZW9sZQ==  saveole  ant@ant:~/native$                                             注意事项          使用 native-image 构建可执行程序时，需要注意当前的执行目录。它默认会扫描当前目录及子目录下的所有文件(不能区分 Java 程序相关的文件)，导致构建失败。建议在单独的文件夹中进行编译构建。      "
  },
  
  {
    "title": "Spring Native 初体验",
    "url": "/posts/spring-native-first-cup/",
    "categories": "技术, Java",
    "tags": "Docker, JVM, Java, GraalVM",
    "date": "2024-04-07 13:30:30 +0800",
    





    
    "snippet": "  项目背景          mqtt 的消费端应用，应用逻辑较简单，主要是消费 mqtt 消息，然后做对应的持久化(写多读少)操作      项目架构主要使用到了 Spring Boot 作为 IoC 容器，MongoDB 作为存储，然后开源的 mqtt-spring-boot-starter 作为 mqtt 客户端      当前存在的问题：                  过度依赖...",
    "content": "  项目背景          mqtt 的消费端应用，应用逻辑较简单，主要是消费 mqtt 消息，然后做对应的持久化(写多读少)操作      项目架构主要使用到了 Spring Boot 作为 IoC 容器，MongoDB 作为存储，然后开源的 mqtt-spring-boot-starter 作为 mqtt 客户端      当前存在的问题：                  过度依赖：依赖了 Spring Web 等本不需要的依赖(这里的 Spring 主要作为 bean 容器)          弹性不足：当消费能力不足需要添加实例的时候，应用启动速度不够快 + 镜像体积较大(451M)          基于spring boot fat jar 的应用内存占用较高                      环境          OS: Ubuntu 22.04      JDK: openjdk 21 GraalVM CE 21+35.1      IDE: IDEA Ultimate 2023.2.5      CPU: i5-12400      内存: 32G 2666Hz        改造内容          JDK 17 → 21      Spring Boot 2.7.0 → 3.3.0      Spring AOT      Dockerfile        存在问题          build 阶段问题                  commons-logging 与 spring jcl 的冲突  → 去除对应的 commons-logging 包                    runtime 阶段问题                  profiles 问题          Java 21 ResourceBundle  → Caused by: java.util.MissingResourceException: Can't find bundle for base name oss, locale en_US                          由 ali-sdk-oss 引入，发现项目中没用到，移除依赖                                运行时 hutool ReflectUtil 使用报错                          改由改写依赖的开源三方库实现，避免使用reflection              mqtt-spring-boot-starter 升级版本后未出现                                mqtt-client 周期性断连/重连          whether JVM Runtime shutdown hook is executed when spring native app exited                    CI/CD                  目前阿里云流水线配置默认不支持，流水线集群默认使用的配置是 1C1G 机器。          将自己的 ecs 主机作为构建机器，发现 2g 的内存不足以进行应用构建，可见 aot 构建的过程是很耗资源的。                      总结体验          资源占用对比                                对比项          jar          native                                      内存占用          212672          7312                          文件大小          28.7M          91.7M                          镜像大小          320M          126M                          启动时间          1.034s          0.077s                            其他更详细的信息见：chat      "
  },
  
  {
    "title": "Win10 Docker 环境安装及设置",
    "url": "/posts/win10-docker-desktop-install-and-setting/",
    "categories": "技术, Docker",
    "tags": "Docker",
    "date": "2023-05-19 13:30:30 +0800",
    





    
    "snippet": "      前置步骤                                                      安装 WSL2 - [安装 WSL              Microsoft Learn](https://learn.microsoft.com/zh-cn/windows/wsl/install)                               ...",
    "content": "      前置步骤                                                      安装 WSL2 - [安装 WSL              Microsoft Learn](https://learn.microsoft.com/zh-cn/windows/wsl/install)                                          在 设置 &gt; 应用 &gt; 程序和功能 &gt; 启用或关闭 Windows 功能 中勾选 Hyper-V 和 适用于 Linux 的 Windows 子系统      重启电脑              安装 Linux 发行版          # 列出可用 linux 发行版本  wsl --list --online  # 安装选定发行版  wsl --install -d &lt;Distribution Name&gt;  # 查看 wsl 安装信息  wsl -l -v                      下载 Docker Desktop for Windows 并安装      Docker Desktop 默认安装到 C 盘，可以将它的数据存储到其他盘      # 先备份 docker-desktop 和 docker-desktop-data 数据  wsl --export docker-desktop docker-desktop.tar  wsl --export docker-desktop-data docker-desktop-data.tar      # 卸载 wsl 中的 docker-desktop 和 docker-desktop-data  wsl --unregister docker-desktop  wsl --unregister docker-desktop-data      # 在其他盘创建存储目录并导入之前的数据  wsl --import docker-desktop D:\\data\\docker-desktop docker-desktop.tar  wsl --import docker-desktop-data D:\\data\\docker-desktop-data docker-desktop-data.tar        重启电脑  遇到的问题                  docker desktop 卸载重装后不能启动          原因：没有在 启用或关闭 Windows 功能 中勾选 Hyper-V                            wsl —list —online 一直没有响应          启用或关闭 Windows 功能 设置变更后需要重启电脑生效                            "
  },
  
  {
    "title": "Spring Boot MVC 自定义参数解析器",
    "url": "/posts/spring-mvc-customized-method-argument-resolver/",
    "categories": "技术, Java",
    "tags": "Spring, Java, Spring Web MVC",
    "date": "2023-05-09 13:30:30 +0800",
    





    
    "snippet": "背景  遗留系统：遗留接口系统为 Golang + Gin + MongoDB 实现, MongoDB collection 的 field 字段为中文名而且不固定(可以通过 excel 文件自定义表头的形式添加), 查询参数是直接传的中文形式, 而且传参不固定(query参数的 key 和 value 都不固定)，如：/api/v1/customers?姓名=张三&amp;录入时间=202...",
    "content": "背景  遗留系统：遗留接口系统为 Golang + Gin + MongoDB 实现, MongoDB collection 的 field 字段为中文名而且不固定(可以通过 excel 文件自定义表头的形式添加), 查询参数是直接传的中文形式, 而且传参不固定(query参数的 key 和 value 都不固定)，如：/api/v1/customers?姓名=张三&amp;录入时间=2022-09-01 00:00:00&amp;录入时间=2022-09-02 23:59:59  问题：go 工程师离职, 后端只有 java 工程师的情况下，将此接口改用 java 重写一遍，但传参方式不变(query key 还是为中文)实现可选方案  方案一：不用 java 改写，java 工程师维护 golang 项目          优点：代码改动最小，出现 bug 的概率也最小      缺点：需要花时间学习 go 语言和相关项目        方案二：获取 HttpServletRequset 对象, 在相应的接口入口层进行参数处理          优点：能够获取到所有参数，快速实现功能      缺点：针对特定接口实现，不利于代码扩展        方案三：自定义 MVC 层参数解析器解析请求参数并绑定          优点：能够抽取此类需求的公共参数,结合反射和注解机制利于相似需求的扩展      缺点：相对于方案二性能可能会差一点。                  涉及到反射处理                    方案三实现  MVC 方法参数处理器接口 HandlerMethodArgumentResolverpublic interface HandlerMethodArgumentResolver {\t/**\t * 此解析器是否支持该方法参数的解析\t */\tboolean supportsParameter(MethodParameter parameter);\t/**\t * 将拿到的原始数据解析成想要的参数对象\t * A {@link ModelAndViewContainer} provides access to the model for the\t * request. A {@link WebDataBinderFactory} provides a way to create\t * a {@link WebDataBinder} instance when needed for data binding and\t * type conversion purposes.\t * @param parameter the method parameter to resolve. This parameter must\t * have previously been passed to {@link #supportsParameter} which must\t * have returned {@code true}.\t * @param mavContainer the ModelAndViewContainer for the current request\t * @param webRequest the current request\t * @param binderFactory a factory for creating {@link WebDataBinder} instances\t * @return the resolved argument value, or {@code null} if not resolvable\t * @throws Exception in case of errors with the preparation of argument values\t */\t@Nullable\tObject resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,\t\t\tNativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception;}  实现自定义方法参数处理器@Slf4jpublic class ZhFieldRequestResolver implements HandlerMethodArgumentResolver {    @Override    public boolean supportsParameter(MethodParameter parameter) {        // 有 ZhBindConvertor 注解的参数才进行解析转换        return parameter.hasParameterAnnotation(ZhBindConvertor.class);    }    @Override    public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer,                                  NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception {        HttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest.class);        assert request != null;        // 获取参数类型，根据参数类型反射创建类型实例        Class&lt;?&gt; resultType = parameter.getParameterType();        return buildResultObject(resultType, request);    }    private Object buildResultObject(Class&lt;?&gt; resultType, HttpServletRequest request) throws InvocationTargetException,            NoSuchMethodException, InstantiationException, IllegalAccessException, IOException {        String method = request.getMethod();        // 根据不同的 http 方法，使用不同的参数构建模式        return switch (method) {            case \"POST\" -&gt; buildResultObjectForPost(resultType, request);            case \"GET\" -&gt; buildResultObjectForGet(resultType, request);            default -&gt; throw new IllegalStateException(\"不支持的 http 方法类型: \" + method);        };    }    /**     * GET 方法直接通过 {@link ServletRequest#getParameterMap()} 方法获取请求参数     */    private Object buildResultObjectForGet(Class&lt;?&gt; resultType, HttpServletRequest request) throws NoSuchMethodException,            InvocationTargetException, InstantiationException, IllegalAccessException {        Map&lt;String, String[]&gt; parameterMap = request.getParameterMap();        Map&lt;String, List&lt;String&gt;&gt; pMap = new HashMap&lt;&gt;();        parameterMap.forEach((k, v) -&gt; pMap.put(k, List.of(v)));        Field[] fields = resultType.getDeclaredFields();        Class&lt;?&gt; superclass = resultType.getSuperclass();        Field[] superFields = null;        if (!superclass.equals(Object.class)) {            superFields = superclass.getDeclaredFields();        }        // 反射实例化参数对象                Object instance = resultType.getDeclaredConstructor(null).newInstance(null);        // 填充对象字段信息                setFieldsForGet(fields, instance, parameterMap, pMap);        if (superFields != null) {            setFieldsForGet(superFields, instance, parameterMap, pMap);        }        return instance;    }    /**     * 通过 field type 来设置对应的字段值     * https://docs.oracle.com/javase/tutorial/reflect/member/fieldTypes.html     */    private void setFieldsForGet(Field[] fields, Object instance, Map&lt;String, String[]&gt; parameterMap, Map&lt;String,            List&lt;String&gt;&gt; pMap) throws IllegalAccessException {        for (Field f : fields) {            f.setAccessible(true);            String typeName = f.getGenericType().getTypeName();            ZhBindAlias bindAlias = f.getAnnotation(ZhBindAlias.class);            if (Objects.nonNull(bindAlias)) {                String name = bindAlias.value();                int index = bindAlias.index();                String[] values = parameterMap.get(name);                if (values != null &amp;&amp; values.length &gt; 0) {                    Object convertValue = FieldTypeConvertor.FieldType.of(typeName).convert(values, index);                    f.set(instance, convertValue);                }                pMap.remove(name);                if (\"extras\".equals(f.getName()) &amp;&amp; !pMap.isEmpty()) {                    f.set(instance, pMap);                }            } else {                String[] values = parameterMap.get(f.getName());                if (values != null &amp;&amp; values.length &gt; 0) {                    Object convertValue = FieldTypeConvertor.FieldType.of(typeName).convertFirst(values);                    f.set(instance, convertValue);                }                pMap.remove(f.getName());            }        }    }    /**     * POST 方法通过获取请求体 json 字符串转请求对象的方式获取参数信息     */    private Object buildResultObjectForPost(Class&lt;?&gt; resultType, HttpServletRequest request) throws NoSuchMethodException,            InvocationTargetException, InstantiationException, IllegalAccessException, IOException {        // 验证 header 的 Content-Type 为 application/json 才能进行后续操作        String contentTypeHeader = request.getHeader(HttpHeaders.CONTENT_TYPE);        if (StringUtils.isBlank(contentTypeHeader) || !contentTypeHeader.equals(MediaType.APPLICATION_JSON_VALUE)) {            throw new IllegalStateException(\"请设置 Content-Type 值为 application/json\");        }        Field[] fields = resultType.getDeclaredFields();        Class&lt;?&gt; superclass = resultType.getSuperclass();        Field[] superFields = null;        if (!superclass.equals(Object.class)) {            superFields = superclass.getDeclaredFields();        }        Object instance = resultType.getDeclaredConstructor(null).newInstance(null);        StringBuilder sb = new StringBuilder();        try (BufferedReader reader = request.getReader()) {            String line = reader.readLine();            while (StringUtils.isNotBlank(line)) {                sb.append(line);                line = reader.readLine();            }            log.info(\"uri:{},请求体参数:{}\", request.getRequestURI(), sb);            JSONObject body = JSON.parseObject(sb.toString());            setFields(fields, body, instance);            setFields(superFields, body, instance);        }        return instance;    }    private void setFields(Field[] fields, JSONObject source, Object target) throws IllegalAccessException {        if (Objects.isNull(fields) || fields.length == 0) return;        for (Field f : fields) {            f.setAccessible(true);            String fName = f.getName();            String typeName = f.getGenericType().getTypeName();            ZhBindAlias bindAlias = f.getAnnotation(ZhBindAlias.class);            if (Objects.nonNull(bindAlias)) {                String name = bindAlias.value();                int index = bindAlias.index();                Object o = source.get(name);                if (\"extras\".equals(fName)) {                    f.set(target, jsonObjectToMap(source));                }                if (Objects.isNull(o)) continue;                Object convertValue = FieldTypeConvertor.FieldType.of(typeName).convertJsonObject(o, index, name);                f.set(target, convertValue);                source.remove(name);            } else {                Object o = source.get(fName);                if (Objects.isNull(o)) continue;                Object convertValue = FieldTypeConvertor.FieldType.of(typeName).convertJsonObject(o, 0, fName);                f.set(target, convertValue);                source.remove(fName);            }        }    }    private Map&lt;String, List&lt;String&gt;&gt; jsonObjectToMap(JSONObject object) {        TypeReference&lt;List&lt;String&gt;&gt; type = new TypeReference&lt;&gt;(){};        Map&lt;String, List&lt;String&gt;&gt; value = new HashMap&lt;&gt;();        object.forEach((k, v) -&gt; {            List&lt;String&gt; list = JSON.parseObject(v.toString(), type);            value.put(k, list);        });        return value;    }}  配置 WebMvcConfigurer 使自定义参数解析器生效@Configurationpublic class WebConfig implements WebMvcConfigurer {    @Override    public void addArgumentResolvers(List&lt;HandlerMethodArgumentResolver&gt; resolvers) {        resolvers.add(new ZhFieldRequestResolver());    }}  自定义注解用于标注解析后的参数接收类/** * 中文请求参数转换,请求实体字段配合 {@link ZhBindAlias} 使用 * 实现原理：自定义实现 mvc 参数转换器 {@link org.springframework.web.method.support.HandlerMethodArgumentResolver} */@Documented@Target(ElementType.PARAMETER)@Retention(RetentionPolicy.RUNTIME)public @interface ZhBindConvertor {    boolean required() default true;}@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)public @interface ZhBindAlias {    /** 字段的中文别名 */    String value();    /** 同名的情况下绑定到第几个参数 */    int index() default 0;    /** 是否默认添加到 query 条件构建中 */    boolean includeQuery() default true;}  抽取公用查询参数类/** * 公共查询参数 */@Datapublic abstract class ZhSearchReq {    @ZhBindAlias(\"录入时间\")    private String startTime;    @ZhBindAlias(value = \"录入时间\", index = 1)    private String endTime;    /** 自定义查询字段(对应变化的部分) */    @ZhBindAlias(value = \"extra\", includeQuery = false)    private Map&lt;String, List&lt;String&gt;&gt; extras;    /**     * 排序字段, json 字符串，示例：     * {“录入时间”: \"ascend\", \"分配时间\": \"descend\"}     * 按录入时间升序，分配时间降序排列，默认升序     */    private String sorter;    @Min(1)    @ZhBindAlias(value = \"current\", includeQuery = false)    private Integer current = 1;    @Min(1)    @ZhBindAlias(value = \"pageSize\", includeQuery = false)    private Integer pageSize = 50;    /** 默认按录入时间降序排列 */    private Sort defaultSort() {        return Sort.by(\"录入时间\").descending();    }    /**     * 获取子类字段的值,子类需要有 getter 方法     * @deprecated     */    private void filedCriteriaForSubClass(Criteria criteria, Field f) {        Method[] methods = this.getClass().getDeclaredMethods();        String name = f.getName();        Stream.of(methods)                .filter(m -&gt; m.getName().startsWith(\"get\") &amp;&amp; m.getName().toLowerCase().contains(name.toLowerCase()))                .findAny()                .ifPresent(m -&gt; {                    try {                        Object value = m.invoke(this, null);                        // filedCriteria(criteria, f, value);                    } catch (IllegalAccessException e) {                        e.printStackTrace();                    } catch (InvocationTargetException e) {                        e.printStackTrace();                    }                });    }    public Sort sort() {        String sorter = getSorter();        if (StringUtils.isEmpty(sorter)) return defaultSort();        HashMap sorterMap = JSONObject.parseObject(sorter, HashMap.class);        if (sorterMap.isEmpty()) return defaultSort();        List&lt;Sort.Order&gt; orders = new ArrayList&lt;&gt;(sorterMap.size());        sorterMap.forEach((k, v) -&gt; {            Sort.Order order;            if (v.equals(\"descend\")) {                order = Sort.Order.desc(k.toString());            } else {                order = Sort.Order.asc(k.toString());            }            orders.add(order);        });        if (orders.isEmpty()) return defaultSort();        return Sort.by(orders);    }    /**     * 由于数据库选型原因，与 MongoDB 查询条件强绑定     */    public Criteria getQueryCriteria() {        Criteria criteria = new Criteria();        Class&lt;? extends ZhSearchReq&gt; reqClass = this.getClass();        Class&lt;?&gt; superclass = reqClass.getSuperclass();        Field[] superFields = new Field[0];        if (!superclass.equals(Object.class)) {            superFields = superclass.getDeclaredFields();        }        Field[] fields = reqClass.getDeclaredFields();        Arrays.stream(fields).forEach(f -&gt; filedCriteria(criteria, f));        Arrays.stream(superFields).forEach(f -&gt; filedCriteria(criteria, f));        if (StringUtils.isNotBlank(getStartTime()) &amp;&amp; StringUtils.isNotBlank(getEndTime())) {            criteria.and(\"录入时间\").gte(getStartTime()).lte(getEndTime());        }        // 对于动态参数的处理        if (MapUtil.isNotEmpty(extras)) {            extras.forEach((k, v) -&gt; {                if (CollUtil.isNotEmpty(v)) {                    // warning 与具体业务逻辑相关,可以前端确定公用的处理模型                    if (!v.contains(\"全选\")) {                        if (v.size() == 1) {                            // 根据业务逻辑确定单值的查询定义                            criteria.and(k).is(v.get(0));                        } else {                            // 根据业务逻辑确定多值的查询定义                            criteria.and(k).in(v);                        }                    }                }            });        }        return criteria;    }    /**     * 对于单个查询参数的处理     */    protected void filedCriteria(Criteria criteria, Field f) {        String fName = f.getName();        if (\"sorter\".equals(fName)) return;        String typeName = f.getGenericType().getTypeName();        ZhBindAlias alias = f.getAnnotation(ZhBindAlias.class);        Object value = null;        try {            f.setAccessible(true);            value = f.get(this);        } catch (IllegalAccessException e) {            // 内部调用，不会有问题            e.printStackTrace();        }        if (Objects.isNull(value)) return;        if (Objects.nonNull(alias)) {            if (!alias.includeQuery()) return;            String where = alias.value();            if (\"java.lang.String\".equals(typeName) &amp;&amp; !where.contains(\"时间\")) {                // 单值采用前缀匹配查询                criteria.and(where).regex(\"^\" + value);            } else if (\"java.util.List&lt;java.lang.String&gt;\".equals(typeName) &amp;&amp; !where.contains(\"时间\")) {                List&lt;String&gt; values = (List&lt;String&gt;) value;                if (!values.contains(\"全选\")) {                    // 多值采用 $in 查询                    criteria.and(where).in(values);                }            }        } else {            // 等值查询            criteria.and(fName).is(value);        }    }}  扩展查询参数类@Datapublic class CustomerSearchReq extends ZhSearchReq {    @ZhBindAlias(\"跟进状态\")    private List&lt;String&gt; followState;    @ZhBindAlias(\"手机号\")    private String mobile;    @ZhBindAlias(\"姓名\")    private String name;}  使用@GetMapping()@Operation(summary = \"线索列表\")public R&lt;PageResult&lt;LinkedHashMap&gt;&gt; searchPage(@ZhBindConvertor CustomerSearchReq searchReq) {    return R.ok(customerSearchService.search(searchReq));}  重构质量保证-测试用例          只写了集成测试用例，保证基本的全流程准确性      总结涉及知识点  Spring          SpringMVC 参数绑定流程及自定义参数解析器实现                  GET 类型请求参数解析          POST 类型请求参数解析                    自定义参数解析器如何配置生效        反射:          根据类型实例化对象      字段信息获取与对象字段设置      字段类型信息获取和区分各种不同类型      父类字段信息获取以及子类字段信息如何获取      对象示例方法信息获取和方法执行        自定义注解的使用  测试用例          使用了 testcontainers + docker mongodb + mockmvc 编写集成测试用例      json 文件 + MongoTemplate#insert 完成测试前数据准备      MongoTemplate#dropCollection 完成测试后数据清理      MockMvc 对于响应数据的各种准确性断言      遇到的问题  父类方法反射获取子类字段的取值(子类实例调用时)          解决：忘记了 f.setAccessible(true);      没有 f.setAccessible(true) 的时候也可以使用调用反射方法 getter + field name 的方式获取值，但很不 clean 也会有更大性能开销？benchmark        spring doc openapi 参数转换器问题          通过 WebMvcConfigurer#addArgumentResolvers 解决      存在的问题及可以继续改进的地方  公用查询参数类只支持一层继承体系类的处理，可以根据业务实际需要做支持处理或做规范  公用查询参数类获取 query 条件的方法与数据库类型以及业务强绑定，可以在这一层根据实际需求再做一层抽象  由于业务逻辑简单，没有做单元测试，只做了集成测试  反射获取字段信息时没有做缓存，可以 benchmark 下看看对于应用的性能提升参考及示例代码代码：custom_mvc_method_argument_resolver参考：Spring From the Trenches: Creating a Custom HandlerMethodArgumentResolvermvc-ann-methodsoracle-reflect-fieldTypes"
  }
  
]

