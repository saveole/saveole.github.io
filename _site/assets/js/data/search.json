[
  
  {
    "title": "Java 应用构建 Docker 镜像的几种方式",
    "url": "/posts/java-app-docker-image/",
    "categories": "博客",
    "tags": "Java, Docker, APM, ppt",
    "date": "2024-07-22 18:10:00 +0800",
    





    
    "snippet": "  Java 应用构建 docker 镜像的几种方式",
    "content": "  Java 应用构建 docker 镜像的几种方式"
  },
  
  {
    "title": "博客方案：Jekyll + Chirpy",
    "url": "/posts/jekyll-chirpy/",
    "categories": "博客",
    "tags": "Jekyll",
    "date": "2024-05-31 13:38:00 +0800",
    





    
    "snippet": "  安装 Jekyll (Ubuntu 24.04)          先装 Ruby 和相关依赖项: sudo apt-get install ruby-full build-essential zlib1g-dev              设置当前用户有 gem 的执行权限          echo '# Install Ruby Gems to ~/gems' &gt;&gt; ~...",
    "content": "  安装 Jekyll (Ubuntu 24.04)          先装 Ruby 和相关依赖项: sudo apt-get install ruby-full build-essential zlib1g-dev              设置当前用户有 gem 的执行权限          echo '# Install Ruby Gems to ~/gems' &gt;&gt; ~/.bashrc  echo 'export GEM_HOME=\"$HOME/gems\"' &gt;&gt; ~/.bashrc  echo 'export PATH=\"$HOME/gems/bin:$PATH\"' &gt;&gt; ~/.bashrc  source ~/.bashrc                    安装 Jekyll: gem install jekyll bundler        使用 Chirpy 主题          Clone 或下载 https://github.com/cotes2020/chirpy-starter 仓库      安装依赖： bundle      启动项目： bundle exec jekyll s      访问：http://localhost:4000        基本配置及写 post          https://chirpy.cotes.page/posts/getting-started/      https://chirpy.cotes.page/posts/write-a-new-post/        初次感受          清新简洁，大方美观，响应迅速      定制项挺多，支持视频/音频等媒体格式      从自己平时写的 Markdown 文件转换过来要改造的内容也挺多的， 可以考虑写个程序做这个事情      其他更细致的体验待自己深入使用再评价            Changelog          准备使用这个作为自己的博客框架，先把博客写起来再谈其他              头像/联系方式等设置        favicon 替换        接入 giscus 评论系统 - martin‘s blog        接入 Google Analytics        国内网络环境加速 - 是否有必要？              和 Gmeek 的简单对比          之前的博客框架主要根据 GitHub Issue as a Blog 和 Gmeek 快速上手 构建的。      Gmeek 是基于 GitHub Issues 的，最大的特点就是简洁, 然后是都基于 GitHub 平台，不用在本地安装各种环境，遇到的最大问题是之前 Gmeek 提供的 Github Action 脚本不兼容，导致后续的构建失败。      Chirpy 对于 Gmeek 的话，我个人感觉页面布局要好一点，可配置的地方也要丰富一点。      "
  },
  
  {
    "title": "GraalVM Native + Base64 编解码命令行小工具开发",
    "url": "/posts/graalvm-native-java-base64-command-line-tool/",
    "categories": "技术, Java",
    "tags": "GraalVM, Java, JShell",
    "date": "2024-04-29 13:38:00 +0800",
    





    
    "snippet": "  初衷：          浏览  V 站 帖子有很多 Base64 加密的信息，希望能够快速解密。        实现：                  v1：直接使用 JShell 命令行运行 Java 代码解密          ant@ant:~$ jshell   |  Welcome to JShell -- Version 17.0.9  |  For an introdu...",
    "content": "  初衷：          浏览  V 站 帖子有很多 Base64 加密的信息，希望能够快速解密。        实现：                  v1：直接使用 JShell 命令行运行 Java 代码解密          ant@ant:~$ jshell   |  Welcome to JShell -- Version 17.0.9  |  For an introduction type: /help intro          jshell&gt; var enc = \"c2F2ZW9sZQ==\"  enc ==&gt; \"c2F2ZW9sZQ==\"          jshell&gt; var decodedBytes = Base64.getDecoder().decode(enc.getBytes())  decodedBytes ==&gt; byte[8] { 115, 97, 118, 101, 95, 111, 108, 101 }          jshell&gt; new String(decodedBytes)  $3 ==&gt; \"saveole\"                            v2：GraalVM Native 的方式将 Java 程序编译打包成可执行文件小工具                              原 Java 程序：              import java.util.Base64;              public class Base64Tool {      static String helpMsg = \"\"\"  \t\t-e Encode input string  \t\t-d Decode input string               \"\"\";;                      public static void main(String[] args) {          if (args == null || args.length == 0) {              System.err.println(helpMsg);              System.exit(1);          }          var arg = args[0];          switch(arg) {            case \"-help\":                System.out.println(helpMsg);                break;            case \"-e\":                var toEncode = getAndCheckArg(args);                System.out.println(new String(Base64.getEncoder().encode(toEncode.getBytes())));                break;            case \"-d\":                var toDecode = getAndCheckArg(args);                System.out.println(new String(Base64.getDecoder().decode(toDecode.getBytes())));                break;            default:                System.err.println(\"Unknown command, use -help to see how to use this tool.\");                break;          }          System.exit(1);      }                  static String getAndCheckArg(String[] args) {          if (args == null || args.length &lt; 2) {              System.err.println(\"Please input valid string\");              System.exit(0);          }          return args[1];      }  }                                            使用 native-image 编译构建可执行程序              ant@ant:~/native$ javac Base64Tool.java   ant@ant:~/native$ native-image Base64Tool  ========================================================================================================================  GraalVM Native Image: Generating 'base64tool' (executable)...  ========================================================================================================================  [1/8] Initializing...                                                                                    (1.7s @ 0.14GB)   Java version: 17.0.9+9, vendor version: GraalVM CE 17.0.9+9.1   Graal compiler: optimization level: 2, target machine: x86-64-v3   C compiler: gcc (linux, x86_64, 11.4.0)   Garbage collector: Serial GC (max heap size: 80% of RAM)  [2/8] Performing analysis...  [****]                                                                     (4.4s @ 0.27GB)     2,912 (71.67%) of  4,063 types reachable     3,536 (50.94%) of  6,942 fields reachable    13,209 (43.86%) of 30,116 methods reachable       907 types,     0 fields, and   348 methods registered for reflection        58 types,    58 fields, and    52 methods registered for JNI access         4 native libraries: dl, pthread, rt, z  [3/8] Building universe...                                                                               (0.9s @ 0.30GB)  [4/8] Parsing methods...      [*]                                                                        (0.6s @ 0.32GB)  [5/8] Inlining methods...     [***]                                                                      (0.5s @ 0.22GB)  [6/8] Compiling methods...    [**]                                                                       (4.5s @ 0.35GB)  [7/8] Layouting methods...    [*]                                                                        (0.7s @ 0.37GB)  [8/8] Creating image...       [*]                                                                        (1.1s @ 0.38GB)     4.42MB (36.75%) for code area:     7,506 compilation units     7.04MB (58.46%) for image heap:   89,275 objects and 5 resources   590.55kB ( 4.79%) for other data    12.03MB in total  ------------------------------------------------------------------------------------------------------------------------  Top 10 origins of code area:                                Top 10 object types in image heap:     3.37MB java.base                                         1009.70kB byte[] for code metadata   795.13kB svm.jar (Native Image)                             889.53kB java.lang.String   112.32kB java.logging                                       836.32kB byte[] for general heap data    62.07kB org.graalvm.nativeimage.base                       671.94kB java.lang.Class    24.15kB jdk.internal.vm.ci                                 665.65kB byte[] for java.lang.String    23.14kB org.graalvm.sdk                                    347.48kB java.util.HashMap$Node     6.11kB jdk.internal.vm.compiler                           250.25kB com.oracle.svm.core.hub.DynamicHubCompanion     1.68kB Base64Tool                                         169.02kB java.lang.String[]     1.35kB jdk.proxy1                                         165.57kB java.lang.Object[]     1.27kB jdk.proxy3                                         148.84kB byte[] for embedded resources     1.56kB for 2 more packages                                  1.20MB for 829 more object types  ------------------------------------------------------------------------------------------------------------------------  Recommendations:   HEAP: Set max heap for improved and more predictable memory usage.   CPU:  Enable more CPU features with '-march=native' for improved performance.  ------------------------------------------------------------------------------------------------------------------------                          0.7s (4.3% of total time) in 164 GCs | Peak RSS: 0.84GB | CPU load: 8.21  ------------------------------------------------------------------------------------------------------------------------  Produced artifacts:   /home/ant/native/base64tool (executable)  ========================================================================================================================  Finished generating 'base64tool' in 14.8s.                                            使用              ant@ant:~/native$ ./base64tool -help  -e Encode input string  -d Decode input string              ant@ant:~/native$ ./base64tool -e saveole  c2F2ZW9sZQ==  ant@ant:~/native$ ./base64tool -d c2F2ZW9sZQ==  saveole  ant@ant:~/native$                                             注意事项          使用 native-image 构建可执行程序时，需要注意当前的执行目录。它默认会扫描当前目录及子目录下的所有文件(不能区分 Java 程序相关的文件)，导致构建失败。建议在单独的文件夹中进行编译构建。      "
  },
  
  {
    "title": "Spring Native 初体验",
    "url": "/posts/spring-native-first-cup/",
    "categories": "技术, Java",
    "tags": "Docker, JVM, Java, GraalVM",
    "date": "2024-04-07 13:30:30 +0800",
    





    
    "snippet": "  项目背景          mqtt 的消费端应用，应用逻辑较简单，主要是消费 mqtt 消息，然后做对应的持久化(写多读少)操作      项目架构主要使用到了 Spring Boot 作为 IoC 容器，MongoDB 作为存储，然后开源的 mqtt-spring-boot-starter 作为 mqtt 客户端      当前存在的问题：                  过度依赖...",
    "content": "  项目背景          mqtt 的消费端应用，应用逻辑较简单，主要是消费 mqtt 消息，然后做对应的持久化(写多读少)操作      项目架构主要使用到了 Spring Boot 作为 IoC 容器，MongoDB 作为存储，然后开源的 mqtt-spring-boot-starter 作为 mqtt 客户端      当前存在的问题：                  过度依赖：依赖了 Spring Web 等本不需要的依赖(这里的 Spring 主要作为 bean 容器)          弹性不足：当消费能力不足需要添加实例的时候，应用启动速度不够快 + 镜像体积较大(451M)          基于spring boot fat jar 的应用内存占用较高                      环境          OS: Ubuntu 22.04      JDK: openjdk 21 GraalVM CE 21+35.1      IDE: IDEA Ultimate 2023.2.5      CPU: i5-12400      内存: 32G 2666Hz        改造内容          JDK 17 → 21      Spring Boot 2.7.0 → 3.3.0      Spring AOT      Dockerfile        存在问题          build 阶段问题                  commons-logging 与 spring jcl 的冲突  → 去除对应的 commons-logging 包                    runtime 阶段问题                  profiles 问题          Java 21 ResourceBundle  → Caused by: java.util.MissingResourceException: Can't find bundle for base name oss, locale en_US                          由 ali-sdk-oss 引入，发现项目中没用到，移除依赖                                运行时 hutool ReflectUtil 使用报错                          改由改写依赖的开源三方库实现，避免使用reflection              mqtt-spring-boot-starter 升级版本后未出现                                mqtt-client 周期性断连/重连          whether JVM Runtime shutdown hook is executed when spring native app exited                    CI/CD                  目前阿里云流水线配置默认不支持，流水线集群默认使用的配置是 1C1G 机器。          将自己的 ecs 主机作为构建机器，发现 2g 的内存不足以进行应用构建，可见 aot 构建的过程是很耗资源的。                      总结体验          资源占用对比                                对比项          jar          native                                      内存占用          212672          7312                          文件大小          28.7M          91.7M                          镜像大小          320M          126M                          启动时间          1.034s          0.077s                            其他更详细的信息见：chat      "
  },
  
  {
    "title": "Win10 Docker 环境安装及设置",
    "url": "/posts/win10-docker-desktop-install-and-setting/",
    "categories": "技术, Docker",
    "tags": "Docker",
    "date": "2023-05-19 13:30:30 +0800",
    





    
    "snippet": "      前置步骤                                                      安装 WSL2 - [安装 WSL              Microsoft Learn](https://learn.microsoft.com/zh-cn/windows/wsl/install)                               ...",
    "content": "      前置步骤                                                      安装 WSL2 - [安装 WSL              Microsoft Learn](https://learn.microsoft.com/zh-cn/windows/wsl/install)                                          在 设置 &gt; 应用 &gt; 程序和功能 &gt; 启用或关闭 Windows 功能 中勾选 Hyper-V 和 适用于 Linux 的 Windows 子系统      重启电脑              安装 Linux 发行版          # 列出可用 linux 发行版本  wsl --list --online  # 安装选定发行版  wsl --install -d &lt;Distribution Name&gt;  # 查看 wsl 安装信息  wsl -l -v                      下载 Docker Desktop for Windows 并安装      Docker Desktop 默认安装到 C 盘，可以将它的数据存储到其他盘      # 先备份 docker-desktop 和 docker-desktop-data 数据  wsl --export docker-desktop docker-desktop.tar  wsl --export docker-desktop-data docker-desktop-data.tar      # 卸载 wsl 中的 docker-desktop 和 docker-desktop-data  wsl --unregister docker-desktop  wsl --unregister docker-desktop-data      # 在其他盘创建存储目录并导入之前的数据  wsl --import docker-desktop D:\\data\\docker-desktop docker-desktop.tar  wsl --import docker-desktop-data D:\\data\\docker-desktop-data docker-desktop-data.tar        重启电脑  遇到的问题                  docker desktop 卸载重装后不能启动          原因：没有在 启用或关闭 Windows 功能 中勾选 Hyper-V                            wsl —list —online 一直没有响应          启用或关闭 Windows 功能 设置变更后需要重启电脑生效                            "
  },
  
  {
    "title": "Spring Boot MVC 自定义参数解析器",
    "url": "/posts/spring-mvc-customized-method-argument-resolver/",
    "categories": "技术, Java",
    "tags": "Spring, Java, Spring Web MVC",
    "date": "2023-05-09 13:30:30 +0800",
    





    
    "snippet": "背景  遗留系统：遗留接口系统为 Golang + Gin + MongoDB 实现, MongoDB collection 的 field 字段为中文名而且不固定(可以通过 excel 文件自定义表头的形式添加), 查询参数是直接传的中文形式, 而且传参不固定(query参数的 key 和 value 都不固定)，如：/api/v1/customers?姓名=张三&amp;录入时间=202...",
    "content": "背景  遗留系统：遗留接口系统为 Golang + Gin + MongoDB 实现, MongoDB collection 的 field 字段为中文名而且不固定(可以通过 excel 文件自定义表头的形式添加), 查询参数是直接传的中文形式, 而且传参不固定(query参数的 key 和 value 都不固定)，如：/api/v1/customers?姓名=张三&amp;录入时间=2022-09-01 00:00:00&amp;录入时间=2022-09-02 23:59:59  问题：go 工程师离职, 后端只有 java 工程师的情况下，将此接口改用 java 重写一遍，但传参方式不变(query key 还是为中文)实现可选方案  方案一：不用 java 改写，java 工程师维护 golang 项目          优点：代码改动最小，出现 bug 的概率也最小      缺点：需要花时间学习 go 语言和相关项目        方案二：获取 HttpServletRequset 对象, 在相应的接口入口层进行参数处理          优点：能够获取到所有参数，快速实现功能      缺点：针对特定接口实现，不利于代码扩展        方案三：自定义 MVC 层参数解析器解析请求参数并绑定          优点：能够抽取此类需求的公共参数,结合反射和注解机制利于相似需求的扩展      缺点：相对于方案二性能可能会差一点。                  涉及到反射处理                    方案三实现  MVC 方法参数处理器接口 HandlerMethodArgumentResolverpublic interface HandlerMethodArgumentResolver {\t/**\t * 此解析器是否支持该方法参数的解析\t */\tboolean supportsParameter(MethodParameter parameter);\t/**\t * 将拿到的原始数据解析成想要的参数对象\t * A {@link ModelAndViewContainer} provides access to the model for the\t * request. A {@link WebDataBinderFactory} provides a way to create\t * a {@link WebDataBinder} instance when needed for data binding and\t * type conversion purposes.\t * @param parameter the method parameter to resolve. This parameter must\t * have previously been passed to {@link #supportsParameter} which must\t * have returned {@code true}.\t * @param mavContainer the ModelAndViewContainer for the current request\t * @param webRequest the current request\t * @param binderFactory a factory for creating {@link WebDataBinder} instances\t * @return the resolved argument value, or {@code null} if not resolvable\t * @throws Exception in case of errors with the preparation of argument values\t */\t@Nullable\tObject resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,\t\t\tNativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception;}  实现自定义方法参数处理器@Slf4jpublic class ZhFieldRequestResolver implements HandlerMethodArgumentResolver {    @Override    public boolean supportsParameter(MethodParameter parameter) {        // 有 ZhBindConvertor 注解的参数才进行解析转换        return parameter.hasParameterAnnotation(ZhBindConvertor.class);    }    @Override    public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer,                                  NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception {        HttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest.class);        assert request != null;        // 获取参数类型，根据参数类型反射创建类型实例        Class&lt;?&gt; resultType = parameter.getParameterType();        return buildResultObject(resultType, request);    }    private Object buildResultObject(Class&lt;?&gt; resultType, HttpServletRequest request) throws InvocationTargetException,            NoSuchMethodException, InstantiationException, IllegalAccessException, IOException {        String method = request.getMethod();        // 根据不同的 http 方法，使用不同的参数构建模式        return switch (method) {            case \"POST\" -&gt; buildResultObjectForPost(resultType, request);            case \"GET\" -&gt; buildResultObjectForGet(resultType, request);            default -&gt; throw new IllegalStateException(\"不支持的 http 方法类型: \" + method);        };    }    /**     * GET 方法直接通过 {@link ServletRequest#getParameterMap()} 方法获取请求参数     */    private Object buildResultObjectForGet(Class&lt;?&gt; resultType, HttpServletRequest request) throws NoSuchMethodException,            InvocationTargetException, InstantiationException, IllegalAccessException {        Map&lt;String, String[]&gt; parameterMap = request.getParameterMap();        Map&lt;String, List&lt;String&gt;&gt; pMap = new HashMap&lt;&gt;();        parameterMap.forEach((k, v) -&gt; pMap.put(k, List.of(v)));        Field[] fields = resultType.getDeclaredFields();        Class&lt;?&gt; superclass = resultType.getSuperclass();        Field[] superFields = null;        if (!superclass.equals(Object.class)) {            superFields = superclass.getDeclaredFields();        }        // 反射实例化参数对象                Object instance = resultType.getDeclaredConstructor(null).newInstance(null);        // 填充对象字段信息                setFieldsForGet(fields, instance, parameterMap, pMap);        if (superFields != null) {            setFieldsForGet(superFields, instance, parameterMap, pMap);        }        return instance;    }    /**     * 通过 field type 来设置对应的字段值     * https://docs.oracle.com/javase/tutorial/reflect/member/fieldTypes.html     */    private void setFieldsForGet(Field[] fields, Object instance, Map&lt;String, String[]&gt; parameterMap, Map&lt;String,            List&lt;String&gt;&gt; pMap) throws IllegalAccessException {        for (Field f : fields) {            f.setAccessible(true);            String typeName = f.getGenericType().getTypeName();            ZhBindAlias bindAlias = f.getAnnotation(ZhBindAlias.class);            if (Objects.nonNull(bindAlias)) {                String name = bindAlias.value();                int index = bindAlias.index();                String[] values = parameterMap.get(name);                if (values != null &amp;&amp; values.length &gt; 0) {                    Object convertValue = FieldTypeConvertor.FieldType.of(typeName).convert(values, index);                    f.set(instance, convertValue);                }                pMap.remove(name);                if (\"extras\".equals(f.getName()) &amp;&amp; !pMap.isEmpty()) {                    f.set(instance, pMap);                }            } else {                String[] values = parameterMap.get(f.getName());                if (values != null &amp;&amp; values.length &gt; 0) {                    Object convertValue = FieldTypeConvertor.FieldType.of(typeName).convertFirst(values);                    f.set(instance, convertValue);                }                pMap.remove(f.getName());            }        }    }    /**     * POST 方法通过获取请求体 json 字符串转请求对象的方式获取参数信息     */    private Object buildResultObjectForPost(Class&lt;?&gt; resultType, HttpServletRequest request) throws NoSuchMethodException,            InvocationTargetException, InstantiationException, IllegalAccessException, IOException {        // 验证 header 的 Content-Type 为 application/json 才能进行后续操作        String contentTypeHeader = request.getHeader(HttpHeaders.CONTENT_TYPE);        if (StringUtils.isBlank(contentTypeHeader) || !contentTypeHeader.equals(MediaType.APPLICATION_JSON_VALUE)) {            throw new IllegalStateException(\"请设置 Content-Type 值为 application/json\");        }        Field[] fields = resultType.getDeclaredFields();        Class&lt;?&gt; superclass = resultType.getSuperclass();        Field[] superFields = null;        if (!superclass.equals(Object.class)) {            superFields = superclass.getDeclaredFields();        }        Object instance = resultType.getDeclaredConstructor(null).newInstance(null);        StringBuilder sb = new StringBuilder();        try (BufferedReader reader = request.getReader()) {            String line = reader.readLine();            while (StringUtils.isNotBlank(line)) {                sb.append(line);                line = reader.readLine();            }            log.info(\"uri:{},请求体参数:{}\", request.getRequestURI(), sb);            JSONObject body = JSON.parseObject(sb.toString());            setFields(fields, body, instance);            setFields(superFields, body, instance);        }        return instance;    }    private void setFields(Field[] fields, JSONObject source, Object target) throws IllegalAccessException {        if (Objects.isNull(fields) || fields.length == 0) return;        for (Field f : fields) {            f.setAccessible(true);            String fName = f.getName();            String typeName = f.getGenericType().getTypeName();            ZhBindAlias bindAlias = f.getAnnotation(ZhBindAlias.class);            if (Objects.nonNull(bindAlias)) {                String name = bindAlias.value();                int index = bindAlias.index();                Object o = source.get(name);                if (\"extras\".equals(fName)) {                    f.set(target, jsonObjectToMap(source));                }                if (Objects.isNull(o)) continue;                Object convertValue = FieldTypeConvertor.FieldType.of(typeName).convertJsonObject(o, index, name);                f.set(target, convertValue);                source.remove(name);            } else {                Object o = source.get(fName);                if (Objects.isNull(o)) continue;                Object convertValue = FieldTypeConvertor.FieldType.of(typeName).convertJsonObject(o, 0, fName);                f.set(target, convertValue);                source.remove(fName);            }        }    }    private Map&lt;String, List&lt;String&gt;&gt; jsonObjectToMap(JSONObject object) {        TypeReference&lt;List&lt;String&gt;&gt; type = new TypeReference&lt;&gt;(){};        Map&lt;String, List&lt;String&gt;&gt; value = new HashMap&lt;&gt;();        object.forEach((k, v) -&gt; {            List&lt;String&gt; list = JSON.parseObject(v.toString(), type);            value.put(k, list);        });        return value;    }}  配置 WebMvcConfigurer 使自定义参数解析器生效@Configurationpublic class WebConfig implements WebMvcConfigurer {    @Override    public void addArgumentResolvers(List&lt;HandlerMethodArgumentResolver&gt; resolvers) {        resolvers.add(new ZhFieldRequestResolver());    }}  自定义注解用于标注解析后的参数接收类/** * 中文请求参数转换,请求实体字段配合 {@link ZhBindAlias} 使用 * 实现原理：自定义实现 mvc 参数转换器 {@link org.springframework.web.method.support.HandlerMethodArgumentResolver} */@Documented@Target(ElementType.PARAMETER)@Retention(RetentionPolicy.RUNTIME)public @interface ZhBindConvertor {    boolean required() default true;}@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)public @interface ZhBindAlias {    /** 字段的中文别名 */    String value();    /** 同名的情况下绑定到第几个参数 */    int index() default 0;    /** 是否默认添加到 query 条件构建中 */    boolean includeQuery() default true;}  抽取公用查询参数类/** * 公共查询参数 */@Datapublic abstract class ZhSearchReq {    @ZhBindAlias(\"录入时间\")    private String startTime;    @ZhBindAlias(value = \"录入时间\", index = 1)    private String endTime;    /** 自定义查询字段(对应变化的部分) */    @ZhBindAlias(value = \"extra\", includeQuery = false)    private Map&lt;String, List&lt;String&gt;&gt; extras;    /**     * 排序字段, json 字符串，示例：     * {“录入时间”: \"ascend\", \"分配时间\": \"descend\"}     * 按录入时间升序，分配时间降序排列，默认升序     */    private String sorter;    @Min(1)    @ZhBindAlias(value = \"current\", includeQuery = false)    private Integer current = 1;    @Min(1)    @ZhBindAlias(value = \"pageSize\", includeQuery = false)    private Integer pageSize = 50;    /** 默认按录入时间降序排列 */    private Sort defaultSort() {        return Sort.by(\"录入时间\").descending();    }    /**     * 获取子类字段的值,子类需要有 getter 方法     * @deprecated     */    private void filedCriteriaForSubClass(Criteria criteria, Field f) {        Method[] methods = this.getClass().getDeclaredMethods();        String name = f.getName();        Stream.of(methods)                .filter(m -&gt; m.getName().startsWith(\"get\") &amp;&amp; m.getName().toLowerCase().contains(name.toLowerCase()))                .findAny()                .ifPresent(m -&gt; {                    try {                        Object value = m.invoke(this, null);                        // filedCriteria(criteria, f, value);                    } catch (IllegalAccessException e) {                        e.printStackTrace();                    } catch (InvocationTargetException e) {                        e.printStackTrace();                    }                });    }    public Sort sort() {        String sorter = getSorter();        if (StringUtils.isEmpty(sorter)) return defaultSort();        HashMap sorterMap = JSONObject.parseObject(sorter, HashMap.class);        if (sorterMap.isEmpty()) return defaultSort();        List&lt;Sort.Order&gt; orders = new ArrayList&lt;&gt;(sorterMap.size());        sorterMap.forEach((k, v) -&gt; {            Sort.Order order;            if (v.equals(\"descend\")) {                order = Sort.Order.desc(k.toString());            } else {                order = Sort.Order.asc(k.toString());            }            orders.add(order);        });        if (orders.isEmpty()) return defaultSort();        return Sort.by(orders);    }    /**     * 由于数据库选型原因，与 MongoDB 查询条件强绑定     */    public Criteria getQueryCriteria() {        Criteria criteria = new Criteria();        Class&lt;? extends ZhSearchReq&gt; reqClass = this.getClass();        Class&lt;?&gt; superclass = reqClass.getSuperclass();        Field[] superFields = new Field[0];        if (!superclass.equals(Object.class)) {            superFields = superclass.getDeclaredFields();        }        Field[] fields = reqClass.getDeclaredFields();        Arrays.stream(fields).forEach(f -&gt; filedCriteria(criteria, f));        Arrays.stream(superFields).forEach(f -&gt; filedCriteria(criteria, f));        if (StringUtils.isNotBlank(getStartTime()) &amp;&amp; StringUtils.isNotBlank(getEndTime())) {            criteria.and(\"录入时间\").gte(getStartTime()).lte(getEndTime());        }        // 对于动态参数的处理        if (MapUtil.isNotEmpty(extras)) {            extras.forEach((k, v) -&gt; {                if (CollUtil.isNotEmpty(v)) {                    // warning 与具体业务逻辑相关,可以前端确定公用的处理模型                    if (!v.contains(\"全选\")) {                        if (v.size() == 1) {                            // 根据业务逻辑确定单值的查询定义                            criteria.and(k).is(v.get(0));                        } else {                            // 根据业务逻辑确定多值的查询定义                            criteria.and(k).in(v);                        }                    }                }            });        }        return criteria;    }    /**     * 对于单个查询参数的处理     */    protected void filedCriteria(Criteria criteria, Field f) {        String fName = f.getName();        if (\"sorter\".equals(fName)) return;        String typeName = f.getGenericType().getTypeName();        ZhBindAlias alias = f.getAnnotation(ZhBindAlias.class);        Object value = null;        try {            f.setAccessible(true);            value = f.get(this);        } catch (IllegalAccessException e) {            // 内部调用，不会有问题            e.printStackTrace();        }        if (Objects.isNull(value)) return;        if (Objects.nonNull(alias)) {            if (!alias.includeQuery()) return;            String where = alias.value();            if (\"java.lang.String\".equals(typeName) &amp;&amp; !where.contains(\"时间\")) {                // 单值采用前缀匹配查询                criteria.and(where).regex(\"^\" + value);            } else if (\"java.util.List&lt;java.lang.String&gt;\".equals(typeName) &amp;&amp; !where.contains(\"时间\")) {                List&lt;String&gt; values = (List&lt;String&gt;) value;                if (!values.contains(\"全选\")) {                    // 多值采用 $in 查询                    criteria.and(where).in(values);                }            }        } else {            // 等值查询            criteria.and(fName).is(value);        }    }}  扩展查询参数类@Datapublic class CustomerSearchReq extends ZhSearchReq {    @ZhBindAlias(\"跟进状态\")    private List&lt;String&gt; followState;    @ZhBindAlias(\"手机号\")    private String mobile;    @ZhBindAlias(\"姓名\")    private String name;}  使用@GetMapping()@Operation(summary = \"线索列表\")public R&lt;PageResult&lt;LinkedHashMap&gt;&gt; searchPage(@ZhBindConvertor CustomerSearchReq searchReq) {    return R.ok(customerSearchService.search(searchReq));}  重构质量保证-测试用例          只写了集成测试用例，保证基本的全流程准确性      总结涉及知识点  Spring          SpringMVC 参数绑定流程及自定义参数解析器实现                  GET 类型请求参数解析          POST 类型请求参数解析                    自定义参数解析器如何配置生效        反射:          根据类型实例化对象      字段信息获取与对象字段设置      字段类型信息获取和区分各种不同类型      父类字段信息获取以及子类字段信息如何获取      对象示例方法信息获取和方法执行        自定义注解的使用  测试用例          使用了 testcontainers + docker mongodb + mockmvc 编写集成测试用例      json 文件 + MongoTemplate#insert 完成测试前数据准备      MongoTemplate#dropCollection 完成测试后数据清理      MockMvc 对于响应数据的各种准确性断言      遇到的问题  父类方法反射获取子类字段的取值(子类实例调用时)          解决：忘记了 f.setAccessible(true);      没有 f.setAccessible(true) 的时候也可以使用调用反射方法 getter + field name 的方式获取值，但很不 clean 也会有更大性能开销？benchmark        spring doc openapi 参数转换器问题          通过 WebMvcConfigurer#addArgumentResolvers 解决      存在的问题及可以继续改进的地方  公用查询参数类只支持一层继承体系类的处理，可以根据业务实际需要做支持处理或做规范  公用查询参数类获取 query 条件的方法与数据库类型以及业务强绑定，可以在这一层根据实际需求再做一层抽象  由于业务逻辑简单，没有做单元测试，只做了集成测试  反射获取字段信息时没有做缓存，可以 benchmark 下看看对于应用的性能提升参考及示例代码代码：custom_mvc_method_argument_resolver参考：Spring From the Trenches: Creating a Custom HandlerMethodArgumentResolvermvc-ann-methodsoracle-reflect-fieldTypes"
  }
  
]

